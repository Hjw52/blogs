(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{563:function(a,s,t){"use strict";t.r(s);var e=t(13),i=Object(e.a)({},(function(){var a=this,s=a.$createElement,t=a._self._c||s;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("p",[t("img",{attrs:{src:"https://github.com/Hjw52/Blog/blob/master/image/image-20201030214221486.png?raw=true",alt:"image-20201030214221486"}})]),a._v(" "),t("p",[a._v("格式化上下文指的是元素所处的环境，在CSS中，每个渲染元素都有它对于的上下文。格式化上下文约束着元素在浏览器如何排列，如何显示及渲染等。通常格式化上下文分为："),t("strong",[a._v("块格式化上下文（BFC）"),t("strong",[a._v("和")]),a._v("行内格式化上下文（IFC）")]),a._v("。要了解格式化上下文，我们先从清除浮动这个问题聊起。")]),a._v(" "),t("h3",{attrs:{id:"清除浮动"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#清除浮动"}},[a._v("#")]),a._v(" 清除浮动")]),a._v(" "),t("p",[a._v("假设我们要实现在一个布局，左右两块自适应屏幕的宽度，同时又要固定在左右两边。大概如下的布局，蓝绿两栏固定左右且均分宽度。父容器包含两子div 背景为灰色。")]),a._v(" "),t("p",[t("img",{attrs:{src:"https://github.com/Hjw52/Blog/blob/master/image/image-20201030205147033.png?raw=true",alt:"image-20201030205147033"}})]),a._v(" "),t("p",[a._v("这很简单，于是我们写了如下代码：")]),a._v(" "),t("p",[t("strong",[a._v("HTML")])]),a._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v('<body>\n        <div class=\'block\'>\n            <div class="left">\n                <h1>hahah</h1>\n                <p>hhhhhhhh</p>\n            </div>\n            <div class="right">\n                <h1>hahah</h1>\n                <p>hhhhhhhh</p>\n            </div>\n        </div>\n    </body>\n')])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br"),t("span",{staticClass:"line-number"},[a._v("2")]),t("br"),t("span",{staticClass:"line-number"},[a._v("3")]),t("br"),t("span",{staticClass:"line-number"},[a._v("4")]),t("br"),t("span",{staticClass:"line-number"},[a._v("5")]),t("br"),t("span",{staticClass:"line-number"},[a._v("6")]),t("br"),t("span",{staticClass:"line-number"},[a._v("7")]),t("br"),t("span",{staticClass:"line-number"},[a._v("8")]),t("br"),t("span",{staticClass:"line-number"},[a._v("9")]),t("br"),t("span",{staticClass:"line-number"},[a._v("10")]),t("br"),t("span",{staticClass:"line-number"},[a._v("11")]),t("br"),t("span",{staticClass:"line-number"},[a._v("12")]),t("br")])]),t("p",[t("strong",[a._v("CSS")])]),a._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v(".block{\n          background-color: darkgray;\n          border: solid 1px black;\n      }\n            .left{\n                float: left;\n                width: 30%;\n                background-color: blue;\n            }\n            .right{\n                float:right;\n                width: 65%;\n                background-color: burlywood;\n            }\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br"),t("span",{staticClass:"line-number"},[a._v("2")]),t("br"),t("span",{staticClass:"line-number"},[a._v("3")]),t("br"),t("span",{staticClass:"line-number"},[a._v("4")]),t("br"),t("span",{staticClass:"line-number"},[a._v("5")]),t("br"),t("span",{staticClass:"line-number"},[a._v("6")]),t("br"),t("span",{staticClass:"line-number"},[a._v("7")]),t("br"),t("span",{staticClass:"line-number"},[a._v("8")]),t("br"),t("span",{staticClass:"line-number"},[a._v("9")]),t("br"),t("span",{staticClass:"line-number"},[a._v("10")]),t("br"),t("span",{staticClass:"line-number"},[a._v("11")]),t("br"),t("span",{staticClass:"line-number"},[a._v("12")]),t("br"),t("span",{staticClass:"line-number"},[a._v("13")]),t("br"),t("span",{staticClass:"line-number"},[a._v("14")]),t("br")])]),t("p",[a._v("运行后却发现，结果是下面的样子，两个子div都超出了父元素，这就是浮动造成的后果。为了让子元素存在父元素中，我们改怎么办呢？")]),a._v(" "),t("p",[t("img",{attrs:{src:"https://github.com/Hjw52/Blog/blob/master/image/image-20201030205116374.png?raw=true",alt:"image-20201030205116374"}})]),a._v(" "),t("p",[a._v("清除浮动的办法有很多，总的来说大概有四种：")]),a._v(" "),t("ol",[t("li",[t("p",[a._v("**使用clear属性：**在包含浮动的容器底部插入空元素，然后使用clear：both 清除左右的浮动。即")]),a._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v(' .clear {\n  clear: both;\n}\n\n\n <div class=\'block clearfix\'>\n            <div class="left">\n                <h1>hahah</h1>\n                <p>hhhhhhhh</p>\n            </div>\n            <div class="right">\n                <h1>hahah</h1>\n                <p>hhhhhhhh</p>\n            </div>\n           <div style="clear: both;"></div> \n </div>\n')])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br"),t("span",{staticClass:"line-number"},[a._v("2")]),t("br"),t("span",{staticClass:"line-number"},[a._v("3")]),t("br"),t("span",{staticClass:"line-number"},[a._v("4")]),t("br"),t("span",{staticClass:"line-number"},[a._v("5")]),t("br"),t("span",{staticClass:"line-number"},[a._v("6")]),t("br"),t("span",{staticClass:"line-number"},[a._v("7")]),t("br"),t("span",{staticClass:"line-number"},[a._v("8")]),t("br"),t("span",{staticClass:"line-number"},[a._v("9")]),t("br"),t("span",{staticClass:"line-number"},[a._v("10")]),t("br"),t("span",{staticClass:"line-number"},[a._v("11")]),t("br"),t("span",{staticClass:"line-number"},[a._v("12")]),t("br"),t("span",{staticClass:"line-number"},[a._v("13")]),t("br"),t("span",{staticClass:"line-number"},[a._v("14")]),t("br"),t("span",{staticClass:"line-number"},[a._v("15")]),t("br"),t("span",{staticClass:"line-number"},[a._v("16")]),t("br")])])]),a._v(" "),t("li",[t("p",[a._v("**.clearfix伪类：**相比前面的方法多了一个HTML元素，如果不想多个元素可以使用伪类的方法。即在父容器增加类 clearfix 。然后使用after伪类来清除浮动 同样可以达到效果。")]),a._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v('.clearfix:before,\n.clearfix:after{\n  content:"";\n  display:table;\n  clear:both;\n}\n')])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br"),t("span",{staticClass:"line-number"},[a._v("2")]),t("br"),t("span",{staticClass:"line-number"},[a._v("3")]),t("br"),t("span",{staticClass:"line-number"},[a._v("4")]),t("br"),t("span",{staticClass:"line-number"},[a._v("5")]),t("br"),t("span",{staticClass:"line-number"},[a._v("6")]),t("br")])])]),a._v(" "),t("li",[t("p",[a._v("**使用overflow：**使用overflow：hidden或overflow：auto来使整个父容器包含浮动元素的高度。（即构成了块格式化上下文，下面会讲到）")])]),a._v(" "),t("li",[t("p",[a._v("**使用min-height：**min-height: contain-floats;这是W3C规范添加的一个新属性，简单的一行代码即可解决浮动的问题，不过目前浏览器支持的较少，几乎没有，但未来肯定大有用处。")])])]),a._v(" "),t("p",[a._v("为什么讲清除浮动，其实解决浮动的方法归纳起来就是使用clear属性和新建块格式化上下文。这边向讲讲clear，浮动元素脱离文档流，只有内容没有高度。clear属性将“清除”的元素上方添加足够的外边距，使其推到浮动元素的下方。如下所示：")]),a._v(" "),t("p",[t("img",{attrs:{src:"https://github.com/Hjw52/Blog/blob/master/image/image-20201030212327693.png?raw=true",alt:"image-20201030212327693"}})]),a._v(" "),t("h2",{attrs:{id:"格式化上下文"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#格式化上下文"}},[a._v("#")]),a._v(" 格式化上下文")]),a._v(" "),t("h3",{attrs:{id:"块级格式化上下文-bfc"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#块级格式化上下文-bfc"}},[a._v("#")]),a._v(" 块级格式化上下文（BFC）")]),a._v(" "),t("p",[a._v("下图为根元素构成的BFC，包含多个块。")]),a._v(" "),t("p",[t("img",{attrs:{src:"https://github.com/Hjw52/Blog/blob/master/image/image-20201030214926309.png?raw=true",alt:"image-20201030214926309"}})]),a._v(" "),t("p",[t("strong",[a._v("特点：")])]),a._v(" "),t("ol",[t("li",[a._v("在一个BFC中，块框按垂直方向排列，相邻块外边距会重叠。（margin重叠问题）")]),a._v(" "),t("li",[a._v("盒子从包含块的最左边摆放，所有块级盒子的左边界默认与包含块的左边界对齐。")]),a._v(" "),t("li",[a._v("BFC包含浮动的元素（这也是上面overflow:hidden；可以自适应浮动元素的原因）")])]),a._v(" "),t("p",[t("strong",[a._v("如何构成BFC：")])]),a._v(" "),t("ul",[t("li",[a._v("根元素本身就是BFC")]),a._v(" "),t("li",[a._v("浮动float不为none")]),a._v(" "),t("li",[a._v("脱离文档流的元素 position：absolute、fixed")]),a._v(" "),t("li",[a._v("display不为block")]),a._v(" "),t("li",[a._v("display为table-cell或table-caption")]),a._v(" "),t("li",[a._v("overflow不为visible的元素")]),a._v(" "),t("li",[a._v("弹性盒子display为flex")])]),a._v(" "),t("h3",{attrs:{id:"行内格式化上下文-ifc"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#行内格式化上下文-ifc"}},[a._v("#")]),a._v(" 行内格式化上下文（IFC）")]),a._v(" "),t("p",[t("img",{attrs:{src:"https://github.com/Hjw52/Blog/blob/master/image/image-20201101140858203.png?raw=true",alt:"image-20201101140858203"}})]),a._v(" "),t("p",[t("img",{attrs:{src:"https://github.com/Hjw52/Blog/blob/master/image/image-20201101133138727.png?raw=true",alt:"image-20201101133138727"}})]),a._v(" "),t("p",[t("strong",[a._v("特点：")])]),a._v(" "),t("ol",[t("li",[a._v("在IFC中每个框都是一个接一个水平排列，起点为包含块的顶部，框的每一行称行框，行框的宽度由它的包含块及浮动元素决定，高度由line-height决定。")]),a._v(" "),t("li",[a._v("盒子一个接一个地水平摆放，容器宽度不够时换行（如不换行则溢出，如上图所示）")]),a._v(" "),t("li",[a._v("每一行生成匿名行盒，包含该行的所有行内级盒")]),a._v(" "),t("li",[a._v("当所有盒总宽度小于匿名行盒宽度时，水平方向的排版由 "),t("code",[a._v("text-align")]),a._v(" 属性来决定，垂直方向上，行内级盒的对齐方式由 "),t("code",[a._v("vertical-align")]),a._v(" 控制，默认对齐为 "),t("code",[a._v("baseline")]),a._v("基线对齐")]),a._v(" "),t("li",[a._v("行内盒垂直的border，padding和margin都不会撑开行盒的高度")])]),a._v(" "),t("p",[t("strong",[a._v("构成IFC：")])]),a._v(" "),t("p",[a._v("​\t当块容器盒（block container box）不包括任何块级盒（block-level boxes）时，就会创建一个行内格式化上下文（IFC）。行盒的高度由其内容最高的一个决定。如果是都是纯 inline 元素，则其高度由最高的 line-height 计算值决定；而如果包括了 inline-block，则 inline-block 的 margin（上下），border（上下），padding（上下），height 都会影响整体行盒的高度。")]),a._v(" "),t("h4",{attrs:{id:"补充-行内元素对齐方式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#补充-行内元素对齐方式"}},[a._v("#")]),a._v(" 补充：行内元素对齐方式")]),a._v(" "),t("p",[a._v("行内元素在盒子内垂直对齐的方式有以下基本线：")]),a._v(" "),t("p",[t("img",{attrs:{src:"https://github.com/Hjw52/Blog/blob/master/image/image-20201101133423320.png?raw=true",alt:"image-20201101133423320"}})]),a._v(" "),t("ul",[t("li",[a._v("基线：如图基线的位置，英文字母的下端，但有少许字母也会超过基线，如g。")]),a._v(" "),t("li",[a._v("中线：英文字母的中间")]),a._v(" "),t("li",[a._v("顶线：父元素内容区的顶部，与fontsize相关")]),a._v(" "),t("li",[a._v("底线：父元素内容区的底部，与fontsize相关")])]),a._v(" "),t("p",[t("strong",[a._v("垂直对齐主要方式Vertical-align")])]),a._v(" "),t("ol",[t("li",[t("p",[a._v("baseline：与父元素的基线对齐")]),a._v(" "),t("p",[t("img",{attrs:{src:"https://github.com/Hjw52/Blog/blob/master/image/image-20201101135603275.png?raw=true",alt:"image-20201101135603275"}})])]),a._v(" "),t("li",[t("p",[a._v("text-top：与父元素字体顶部对齐")]),a._v(" "),t("p",[t("img",{attrs:{src:"https://github.com/Hjw52/Blog/blob/master/image/image-20201101135755033.png?raw=true",alt:"image-20201101135755033"}})])]),a._v(" "),t("li",[t("p",[a._v("text-bottom：与父元素字体底部对齐")]),a._v(" "),t("p",[t("img",{attrs:{src:"https://github.com/Hjw52/Blog/blob/master/image/image-20201101140026373.png?raw=true",alt:"image-20201101140026373"}})])]),a._v(" "),t("li",[t("p",[a._v("middle：居中对齐，将元素中间与基线对齐加上父元素x-height的一半。（x-height为行高与内容区的高度差）")]),a._v(" "),t("p",[t("img",{attrs:{src:"https://github.com/Hjw52/Blog/blob/master/image/image-20201101140103038.png?raw=true",alt:"image-20201101140103038"}})])])])])}),[],!1,null,null,null);s.default=i.exports}}]);