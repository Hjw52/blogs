(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{576:function(e,t,a){"use strict";a.r(t);var v=a(13),s=Object(v.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h3",{attrs:{id:"概述"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#概述"}},[e._v("#")]),e._v(" 概述")]),e._v(" "),a("p",[e._v("HTTP是⼀个属于应⽤层的⾯向对象的协议，由于其简捷、快速的⽅式，适⽤于分布式超媒体信息系 统。 HTTP协议的主要特点可概括如下：")]),e._v(" "),a("p",[e._v("1.⽀持客户/服务器模式。")]),e._v(" "),a("p",[e._v("2.简单快速：客户向服务器请求服务时，只需传送请求⽅法和路径。请求⽅法常⽤的有GET、HEAD、 POST。每种⽅法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序 规模⼩，因⽽通信速度很快。")]),e._v(" "),a("p",[e._v("3.灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。")]),e._v(" "),a("p",[e._v("4.⽆连接：⽆连接的含义是限制每次连接只处理⼀个请求。服务器处理完客户的请求，并收到客户的应 答后，即断开连接。采⽤这种⽅式可以节省传输时间。")]),e._v(" "),a("p",[e._v("5.⽆状态：HTTP协议是⽆状态协议。⽆状态是指协议对于事务处理没有记忆能⼒。缺少状态意味着如果 后续处理需要前⾯的信息，则它必须重传，这样可能导致每次连接传送的数据量增⼤。另⼀⽅⾯，在服 务器不需要先前信息时它的应答就较快。")]),e._v(" "),a("p",[a("img",{attrs:{src:"https://github.com/Hjw52/Blog/blob/master/image/image-20201015220702481.png?raw=true",alt:"image-20201015220702481"}})]),e._v(" "),a("p",[a("img",{attrs:{src:"https://github.com/Hjw52/Blog/blob/master/image/image-20201015220630489.png?raw=true",alt:"image-20201015220630489"}})]),e._v(" "),a("h3",{attrs:{id:"请求"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#请求"}},[e._v("#")]),e._v(" 请求")]),e._v(" "),a("p",[e._v("http请求由三部分组成，分别是：请求⾏、消息报头、请求正⽂。")]),e._v(" "),a("p",[e._v("1、请求⾏以⼀个⽅法符号开头，以空格分开，后⾯跟着请求的URI和协议的版本，格式如下：")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("Method Request-URI HTTP-Version CRLF\n//举例\nGET /form.html HTTP/1.1 (CRLF)\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br")])]),a("p",[e._v("其中 Method表示请求⽅法；Request-URI是⼀个统⼀资源标识符；HTTP-Version表示请求的HTTP协 议版本；CRLF表示回⻋和换⾏（除了作为结尾的CRLF外，不允许出现单独的CR或LF字符）。请求⽅法（所有⽅法全为⼤写）有多种，各个⽅法的解释如下：")]),e._v(" "),a("ul",[a("li",[e._v("GET 请求获取Request-URI所标识的资源")]),e._v(" "),a("li",[e._v("POST 在Request-URI所标识的资源后附加新的数据")]),e._v(" "),a("li",[e._v("HEAD 请求获取由Request-URI所标识的资源的响应消息报头")]),e._v(" "),a("li",[e._v("PUT 请求服务器存储⼀个资源，并⽤Request-URI作为其标识")]),e._v(" "),a("li",[e._v("DELETE 请求服务器删除Request-URI所标识的资源")]),e._v(" "),a("li",[e._v("TRACE 请求服务器回送收到的请求信息，主要⽤于测试或诊断")]),e._v(" "),a("li",[e._v("CONNECT 保留将来使⽤")]),e._v(" "),a("li",[e._v("OPTIONS 请求查询服务器的性能，或者查询与资源相关的选项和需求")])]),e._v(" "),a("p",[e._v("HEAD⽅法与GET⽅法⼏乎是⼀样的，对于HEAD请求的回应部分来说，它的HTTP头部中包含的信息与 通过GET请求所得到的信息是相同的。利⽤这个⽅法，不必传输整个资源内容，就可以得到RequestURI所标识的资源的信息。该⽅法常⽤于测试超链接的有效性，是否可以访问，以及最近是否更新。")]),e._v(" "),a("h3",{attrs:{id:"响应"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#响应"}},[e._v("#")]),e._v(" 响应")]),e._v(" "),a("p",[e._v("在接收和解释请求消息后，服务器返回⼀个HTTP响应消息。 HTTP响应也是由三个部分组成，分别是：状态⾏、消息报头、响应正⽂。")]),e._v(" "),a("p",[e._v("1、状态⾏格式如下：")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("HTTP-Version Status-Code Reason-Phrase CRLF\n//举例\neg：HTTP/1.1 200 OK （CRLF）\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br")])]),a("p",[e._v("其中，HTTP-Version表示服务器HTTP协议的版本；Status-Code表示服务器发回的响应状态代码； Reason-Phrase表示状态代码的⽂本描述。")]),e._v(" "),a("p",[e._v("状态代码有三位数字组成，第⼀个数字定义了响应的类别，且有五种可能取值：")]),e._v(" "),a("ul",[a("li",[e._v("1xx：指示信息--表示请求已接收，继续处理")]),e._v(" "),a("li",[e._v("2xx：成功--表示请求已被成功接收、理解、接受")]),e._v(" "),a("li",[e._v("3xx：重定向--要完成请求必须进⾏更进⼀步的操作")]),e._v(" "),a("li",[e._v("4xx：客户端错误--请求有语法错误或请求⽆法实现")]),e._v(" "),a("li",[e._v("5xx：服务器端错误--服务器未能实现合法的请求")])]),e._v(" "),a("p",[e._v("常⻅状态代码、状态描述、说明：")]),e._v(" "),a("ul",[a("li",[e._v("200 OK //客户端请求成功")]),e._v(" "),a("li",[e._v("400 Bad Request //客户端请求有语法错误，不能被服务器所理解")]),e._v(" "),a("li",[e._v("401 Unauthorized //请求未经授权，这个状态代码必须和WWW-Authenticate报头域⼀起使⽤")]),e._v(" "),a("li",[e._v("403 Forbidden //服务器收到请求，但是拒绝提供服务")]),e._v(" "),a("li",[e._v("404 Not Found //请求资源不存在，eg：输⼊了错误的URL")]),e._v(" "),a("li",[e._v("500 Internal Server Error //服务器发⽣不可预期的错误")]),e._v(" "),a("li",[e._v("503 Server Unavailable //服务器当前不能处理客户端的请求，⼀段时间后可能恢复正常")])]),e._v(" "),a("h3",{attrs:{id:"消息报头"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#消息报头"}},[e._v("#")]),e._v(" 消息报头")]),e._v(" "),a("p",[e._v("HTTP消息由客户端到服务器的请求和服务器到客户端的响应组成。请求消息和响应消息都是由开始⾏ （对于请求消息，开始⾏就是请求⾏，对于响应消息，开始⾏就是状态⾏），消息报头（可选），空⾏ （只有CRLF的⾏），消息正⽂（可选）组成。")]),e._v(" "),a("p",[e._v("HTTP消息报头包括普通报头、请求报头、响应报头、实体报头。 每⼀个报头域都是由 名字+“:”+空格+值 组成，消息报头域的名字是⼤⼩写⽆关的。")]),e._v(" "),a("p",[e._v("1、普通报头")]),e._v(" "),a("p",[e._v("在普通报头中，有少数报头域⽤于所有的请求和响应消息，但并不⽤于被传输的实体，只⽤于传输的消息。")]),e._v(" "),a("p",[e._v("eg：")]),e._v(" "),a("ul",[a("li",[e._v("Cache-Control ⽤于指定缓存指令，缓存指令是单向的（响应中出现的缓存指令在请求中未必会出 现），且是独⽴的（⼀个消息的缓存指令不会影响另⼀个消息处理的缓存机制），HTTP1.0使⽤的类似 的报头域为Pragma。")])]),e._v(" "),a("p",[e._v("请求时的缓存指令包括：no-cache（⽤于指示请求或响应消息不能缓存）、no-store、max-age、 max-stale、min-fresh、only-if-cached;")]),e._v(" "),a("p",[e._v("响应时的缓存指令包括：public、private、no-cache、no-store、no-transform、must-revalidate、 proxy-revalidate、max-age、s-maxage.")]),e._v(" "),a("p",[e._v("eg：为了指示IE浏览器（客户端）不要缓存⻚⾯，服务器端的node.js程序可以编写如下：")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('response.setHeader("Cache-Control","no-cache");\n')])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("这句代码将在发送的响应消息中设置普通报头域：Cache-Control:no-cache。")]),e._v(" "),a("ul",[a("li",[a("p",[e._v("Date普通报头域表示消息产⽣的⽇期和时间")])]),e._v(" "),a("li",[a("p",[e._v("Connection普通报头域允许发送指定连接的选项。例如指定连接是连续，或者指定“close”选项，通知服 务器，在响应完成后，关闭连接")])])]),e._v(" "),a("p",[e._v("2、请求报头")]),e._v(" "),a("p",[e._v("请求报头允许客户端向服务器端传递请求的附加信息以及客户端⾃身的信息。常⽤的请求报头：")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('//请求头\nGET /form.html HTTP/1.1 (CRLF)\nAccept:image/gif,image/x-xbitmap,image/jpeg,application/x-shockwaveflash,application/vnd.ms-excel,application/vnd.mspowerpoint,application/msword,*/* (CRLF)\nAccept-Language:zh-cn (CRLF)\nAccept-Encoding:gzip,deflate (CRLF)\nIf-Modified-Since:Wed,05 Jan 2007 11:21:25 GMT (CRLF)\nIf-None-Match:W/"80b1a4c018f3c41:8317" (CRLF)\nUser-Agent:Mozilla/4.0(compatible;MSIE6.0;Windows NT 5.0) (CRLF)\nHost:www.guet.edu.cn (CRLF)\nConnection:Keep-Alive (CRLF)\n')])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br"),a("span",{staticClass:"line-number"},[e._v("8")]),a("br"),a("span",{staticClass:"line-number"},[e._v("9")]),a("br"),a("span",{staticClass:"line-number"},[e._v("10")]),a("br")])]),a("ul",[a("li",[a("p",[e._v("Accept")]),e._v(" "),a("p",[e._v("Accept请求报头域⽤于指定客户端接受哪些类型的信息。eg：Accept：image/gif，表明客户端希望接 受GIF图象格式的资源；Accept：text/html，表明客户端希望接受html⽂本。")])]),e._v(" "),a("li",[a("p",[e._v("Accept-Charset")]),e._v(" "),a("p",[e._v("Accept-Charset请求报头域⽤于指定客户端接受的字符集。eg：Accept-Charset:iso-8859-1,gb2312.如 果在请求消息中没有设置这个域，缺省是任何字符集都可以接受。")])]),e._v(" "),a("li",[a("p",[e._v("Accept-Encoding")]),e._v(" "),a("p",[e._v("Accept-Encoding请求报头域类似于Accept，但是它是⽤于指定可接受的内容编码。eg：AcceptEncoding: gzip（gzip压缩）.deflate.br（br压缩）如果请求消息中没有设置这个域服务器假定客户端对各种内容编码都可以接受。")])]),e._v(" "),a("li",[a("p",[e._v("Accept-Language")]),e._v(" "),a("p",[e._v("Accept-Language请求报头域类似于Accept，但是它是⽤于指定⼀种⾃然语⾔。eg：AcceptLanguage:zh-cn.如果请求消息中没有设置这个报头域，服务器假定客户端对各种语⾔都可以接受。")])]),e._v(" "),a("li",[a("p",[e._v("Authorization")]),e._v(" "),a("p",[e._v("Authorization请求报头域主要⽤于证明客户端有权查看某个资源。当浏览器访问⼀个⻚⾯时，如果收到 服务器的响应代码为401（未授权），可以发送⼀个包含Authorization请求报头域的请求，要求服务器 对其进⾏验证。")])]),e._v(" "),a("li",[a("p",[e._v("User-Agent（用户代理）")]),e._v(" "),a("p",[e._v("我们上⽹登陆论坛的时候，往往会看到⼀些欢迎信息，其中列出了你的操作系统的名称和版本，你所使⽤的浏览器的名称和版本，这往往让很多⼈感到很神奇，实际上，服务器应⽤程序就是从User-Agent这 个请求报头域中获取到这些信息。User-Agent请求报头域允许客户端将它的操作系统、浏览器和其它属 性告诉服务器。不过，这个报头域不是必需的，如果我们⾃⼰编写⼀个浏览器，不使⽤User-Agent请求 报头域，那么服务器端就⽆法得知我们的信息了。")])])]),e._v(" "),a("p",[e._v("3、响应报头")]),e._v(" "),a("p",[e._v("响应报头允许服务器传递不能放在状态⾏中的附加响应信息，以及关于服务器的信息和对Request-URI 所标识的资源进⾏下⼀步访问的信息。常⽤的响应报头：")]),e._v(" "),a("ul",[a("li",[a("p",[e._v("Location")]),e._v(" "),a("p",[e._v("Location响应报头域⽤于重定向接受者到⼀个新的位置。Location响应报头域常⽤在更换域名的时候。")])]),e._v(" "),a("li",[a("p",[e._v("Server")]),e._v(" "),a("p",[e._v("Server响应报头域包含了服务器⽤来处理请求的软件信息。与User-Agent请求报头域是相对应的。例如：")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("Server：Apache-Coyote/1.1\nWWW-Authenticate\nWWW-Authenticate响应报头域必须被包含在401（未授权的）响应消息中，客户端收到401响应消息\n时候，并发送Authorization报头域请求服务器对其进⾏验证时，服务端响应报头就包含该报头域。\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br")])])])]),e._v(" "),a("p",[e._v("4、实体报头")]),e._v(" "),a("p",[e._v("请求和响应消息都可以传送⼀个实体。⼀个实体由实体报头域和实体正⽂组成，但并不是说实体报头域 和实体正⽂要在⼀起发送，可以只发送实体报头域。实体报头定义了关于实体正⽂（eg：有⽆实体正 ⽂）和请求所标识的资源的元信息。常⽤的实体报头：")]),e._v(" "),a("ul",[a("li",[a("p",[e._v("Content-Encoding")]),e._v(" "),a("p",[e._v("Content-Encoding实体报头域被⽤作媒体类型的修饰符，它的值指示了已经被应⽤到实体正⽂的附加内 容的编码，因⽽要获得Content-Type报头域中所引⽤的媒体类型，必须采⽤相应的解码机制。ContentEncoding这样⽤于记录⽂档的压缩⽅法，eg：Content-Encoding：gzip ，br")])]),e._v(" "),a("li",[a("p",[e._v("Content-Language")]),e._v(" "),a("p",[e._v("Content-Language实体报头域描述了资源所⽤的⾃然语⾔。没有设置该域则认为实体内容将提供给所有的语⾔阅读者。eg：Content-Language:da")])]),e._v(" "),a("li",[a("p",[e._v("Content-Length")]),e._v(" "),a("p",[e._v("Content-Length实体报头域⽤于指明实体正⽂的⻓度，以字节⽅式存储的⼗进制数字来表示。")])]),e._v(" "),a("li",[a("p",[e._v("Content-Type")]),e._v(" "),a("p",[e._v("Content-Type实体报头域⽤语指明发送给接收者的实体正⽂的媒体类型。")]),e._v(" "),a("p",[e._v("eg：")]),e._v(" "),a("p",[e._v("Content-Type:text/html;charset=UTF-8")]),e._v(" "),a("p",[e._v("Content-Type:application/json;charset=UTF-8")])]),e._v(" "),a("li",[a("p",[e._v("Last-Modified")]),e._v(" "),a("p",[e._v("Last-Modified实体报头域⽤于指示资源的最后修改⽇期和时间。")])]),e._v(" "),a("li",[a("p",[e._v("Expires")]),e._v(" "),a("p",[e._v("Expires实体报头域给出响应过期的⽇期和时间。为了让代理服务器或浏览器在⼀段时间以后更新缓存中 (再次访问曾访问过的⻚⾯时，直接从缓存中加载，缩短响应时间和降低服务器负载)的⻚⾯，我们可以 使⽤Expires实体报头域指定⻚⾯过期的时间。eg：Expires：Thu，15 Sep 2006 16:23:12 GMT")]),e._v(" "),a("p",[e._v('HTTP1.1的客户端和缓存必须将其他⾮法的⽇期格式（包括0）看作已经过期。eg：为了让浏览器不要缓存⻚⾯，我们也可以利⽤Expires实体报头域，设置为0，jsp中程序如下： response.setDateHeader("Expires","0");')])])]),e._v(" "),a("h2",{attrs:{id:"http请求处理的发展"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#http请求处理的发展"}},[e._v("#")]),e._v(" Http请求处理的发展")]),e._v(" "),a("ol",[a("li",[e._v("http1.0的时候，一个http请求的生命周期是客户端发起请求，服务器响应，断开连接。但是我们知道tcp协议的缺点就是，三次握手需要时间，再加上慢开始等特性，每一个http请求都这样的话，效率就很低。")]),e._v(" "),a("li",[e._v("http1.1的时候，默认开启了长连接（客户端请求中设置了keep-alive头），服务器处理一个请求后，不会立刻关闭连接，而是会等待一定的时间。如果没有请求才关闭连接。这样浏览器不仅可以在一个tcp连接中，不断地发送请求（服务器也会限制一个连接上可以处理的请求阈值），甚至可以一次发很多个请求。这就是http1.1的管道化（pipeline）技术。但是他也有个问题，因为对于基于http协议的客户端来说，虽然他可以发很多请求出去，但是当一个请求对于的回包回来时，他却无法分辨是属于哪个请求的。所以回包只能按请求顺序返回，这就引来了另一个问题-线头阻塞(Head-of-Link Blocking)。并且http1.1虽然支持长连接，但是他不支持服务端推送（push）的能力。如果服务器有数据要给客户端，也只能等着客户端来取（pull）。")]),e._v(" "),a("li",[e._v("来到了http2.0，不仅实现了服务器推送，还使用了帧（iframe），流（stream）等技术解决了线头阻塞的问题，http2.0在一个tcp连接中，可以同时发送多个http请求，每个请求是一个流，一个流可以分成很多帧，有了标记号，服务器可以随便发送回包，客户端收到后，根据标记，重新组装就可以。")])]),e._v(" "),a("h3",{attrs:{id:"http1-1"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#http1-1"}},[e._v("#")]),e._v(" HTTP1.1")]),e._v(" "),a("ul",[a("li",[a("p",[e._v("长连接")]),e._v(" "),a("p",[e._v("长连接通过请求头的keep-alive信息来控制，HTTP1.1默认包含，而在HTTP1.0中，也可手动开启。它让多个请求复用一个连接，减少握手时间的开销。")])]),e._v(" "),a("li",[a("p",[e._v("协议拓展切换")]),e._v(" "),a("p",[e._v("HTTP1.1包含的upgrade头让服务端知道它能支持其他备用的通信协议。比如从HTTP升级到websocket，通过Connection：Upgrade，Ugrade：websocket来升级到websocket。101状态码表示切换协议。")]),e._v(" "),a("p",[a("img",{attrs:{src:"https://github.com/Hjw52/Blog/blob/master/image/image-20201017212149338.png?raw=true",alt:"image-20201017212149338"}})])]),e._v(" "),a("li",[a("p",[e._v("缓存控制")]),e._v(" "),a("p",[e._v("HTTP1.0主要通过expires和last-modify来控制强缓存和协商缓存，而在HTTP1.1后新增了cache-control和Etag来控制。cache-control使用相对时间优先级高于使用绝对时间的expires。浏览器对发起得请求一般是：先强缓存，后协商缓存。")]),e._v(" "),a("p",[a("img",{attrs:{src:"https://github.com/Hjw52/Blog/blob/master/image/image-20201017212756144.png?raw=true",alt:"image-20201017212756144"}})])]),e._v(" "),a("li",[a("p",[e._v("部分内容传输优化")]),e._v(" "),a("p",[e._v("它可以支持超文本文件的部分传输，同时请求中还能携带数据参数信息。")])])]),e._v(" "),a("h3",{attrs:{id:"http2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#http2"}},[e._v("#")]),e._v(" HTTP2")]),e._v(" "),a("p",[e._v("HTTP协议的下一代版本，以SPDY协议为基础建立，压缩大量头部。相比HTTP，有以下改进：")]),e._v(" "),a("ul",[a("li",[a("p",[e._v("二进制分帧")]),e._v(" "),a("p",[e._v("采用二进制的格式来传输数据，在网络中传输的基本单位为帧，这就形成了帧的传输网络流。")])]),e._v(" "),a("li",[a("p",[e._v("TCP多路复用")]),e._v(" "),a("p",[e._v("HTTP1.1中keep-alive复用的是应用层，且串行复用。而TCP复用的在传输层，复用的是帧，即不同文件的传输帧可以在一个TCP连接并行地流式传输。")])]),e._v(" "),a("li",[a("p",[e._v("传输流优先级")]),e._v(" "),a("p",[e._v("HTTP2中每个文件都有自己的传输优先级，服务器保证优先级高的文件先传输。这样浏览器就可以自动优化先加载CSS文件后加载JavaScript文件。")])]),e._v(" "),a("li",[a("p",[e._v("服务端推送")]),e._v(" "),a("p",[e._v("支持服务器在特定条件下把资源主动推给客户端，就像资源预加载一样。")])])])])}),[],!1,null,null,null);t.default=s.exports}}]);