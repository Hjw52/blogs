(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{572:function(e,s,a){"use strict";a.r(s);var t=a(13),n=Object(t.a)({},(function(){var e=this,s=e.$createElement,a=e._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h3",{attrs:{id:"vue3新特性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue3新特性"}},[e._v("#")]),e._v(" Vue3新特性")]),e._v(" "),a("ol",[a("li",[a("p",[a("strong",[e._v("composition API。")])]),e._v(" "),a("p",[e._v("不同于Vue2的选项式API，组合式API将组件初始化时使用setup方法，包含所有数据、方法，并统一返回。")]),e._v(" "),a("p",[e._v("举个例子：")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("Vue3 composition API：\n\n<script>\nexport default{\n\tsetup（）{\n\t\tconst count =ref (0);\n        const add=()=>{\n        \tcount.value++;\n        }\n\t\treturn {\n\t\t\tcount,\n\t\t\tadd\n\t\t}\n\t}\n}\n<\/script>\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br"),a("span",{staticClass:"line-number"},[e._v("8")]),a("br"),a("span",{staticClass:"line-number"},[e._v("9")]),a("br"),a("span",{staticClass:"line-number"},[e._v("10")]),a("br"),a("span",{staticClass:"line-number"},[e._v("11")]),a("br"),a("span",{staticClass:"line-number"},[e._v("12")]),a("br"),a("span",{staticClass:"line-number"},[e._v("13")]),a("br"),a("span",{staticClass:"line-number"},[e._v("14")]),a("br"),a("span",{staticClass:"line-number"},[e._v("15")]),a("br"),a("span",{staticClass:"line-number"},[e._v("16")]),a("br")])])]),e._v(" "),a("li",[a("p",[a("strong",[e._v("基于Proxy的响应式。")])]),e._v(" "),a("p",[e._v("Vue2中响应式数据是通过ES5的数据劫持setter/getter 来实现的，使用的是object.defineproperty，但只能对现有的对象属性进行劫持，针对的是对象上的属性，尽管做一些重写也不能完全覆盖数据变更的地方（比如动态向对象上添加Key，或通过下标的方式修改数组。）")]),e._v(" "),a("p",[e._v("在Vue3中响应式数据使用的是Proxy，针对的是整个对象，直接代理对象，修改代理对象时拦截数据的变化。")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("const data={}\n\nconst dataProxy=new Proxy(data,{\n\tset(target,key,val){\n\t//代理对象\n\t\tReflact.set()\n\t}\n\tget(target,key,val){\n\t\t//\n\t\tReflact.get()\n\t}\n})\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br"),a("span",{staticClass:"line-number"},[e._v("8")]),a("br"),a("span",{staticClass:"line-number"},[e._v("9")]),a("br"),a("span",{staticClass:"line-number"},[e._v("10")]),a("br"),a("span",{staticClass:"line-number"},[e._v("11")]),a("br"),a("span",{staticClass:"line-number"},[e._v("12")]),a("br")])]),a("p",[e._v("Proxy.revocable()方法可以用来创建一个可撤销的代理对象。")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("const target = { name: 'vuejs'}\nconst {proxy, revoke} = Proxy.revocable(target, handler)\nproxy.name // 正常取值输出 vuejs\nrevoke() // 取值完成对proxy进行封闭，撤消代理\nproxy.name // TypeError: Revoked\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br")])]),a("p",[e._v("但Proxy只有在ES6的环境使用，还无法编译降级。")])]),e._v(" "),a("li",[a("p",[a("strong",[e._v("Tree-shaking的优化。")])]),e._v(" "),a("p",[e._v("在使用Vue3时可以选择按需选择引入相应的模块，而不是一次性引入所有代码，这样打包时Vue3可以将没有引用的源码移除，从而减少体积。")])]),e._v(" "),a("li",[a("p",[a("strong",[e._v("渲染性能的优化。")])]),e._v(" "),a("p",[e._v("Vue3将静态节点、子树等渲染代码移到渲染函数之外，这样可以避免每次渲染时重新创建这些不会变化的对象。将元素的更新类型进行细分，例如动态绑定的部分如果只涉及到 class，则在对比时只需要对比 class 即可，不需要对比它的内容。此外，Vue3还有不少变化，比如模板中支持了多根节点的组件等，这边就不一一介绍。")])])]),e._v(" "),a("h3",{attrs:{id:"代码结构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#代码结构"}},[e._v("#")]),e._v(" 代码结构")]),e._v(" "),a("p",[e._v("Vue3的代码主要分packages和scripts两个目录，script主要用于代码检查、打包等工程操作，真正的源码位于packages目录下，一共有13个包：")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("compiler-core")]),e._v(" 模板解析核心，与具体环境无关，主要生成 AST，并根据 AST 生成 "),a("code",[e._v("render()")]),e._v(" 方法")]),e._v(" "),a("li",[a("code",[e._v("compiler-dom")]),e._v(" 浏览器环境中的模板解析逻辑，如处理 HTML 转义、处理 v-model 等指令")]),e._v(" "),a("li",[a("code",[e._v("compiler-sfc")]),e._v(" 负责解析 Vue 单文件组件，在前面 vue-loader 的解析中有讲解过")]),e._v(" "),a("li",[a("code",[e._v("compiler-ssr")]),e._v(" 服务端渲染环境中的模板解析逻辑")]),e._v(" "),a("li",[a("code",[e._v("reactivity")]),e._v(" 响应式数据相关逻辑")]),e._v(" "),a("li",[a("code",[e._v("runtime-core")]),e._v(" 与平台无关的运行时核心，包括 render")]),e._v(" "),a("li",[a("code",[e._v("runtime-dom")]),e._v(" 浏览器环境中的运行时核心")]),e._v(" "),a("li",[a("code",[e._v("runtime-test")]),e._v(" 用于自动化测试的相关配套")]),e._v(" "),a("li",[a("code",[e._v("server-renderer")]),e._v(" 用于 SSR 服务端渲染的逻辑")]),e._v(" "),a("li",[a("code",[e._v("shared")]),e._v(" 一些各个包之间共享的公共工具")]),e._v(" "),a("li",[a("code",[e._v("size-check")]),e._v(" 一个用于测试 tree shaking 后代码大小的示例库")]),e._v(" "),a("li",[a("code",[e._v("template-explorer")]),e._v(" 用于检查模板编译后的输出，主要用于开发调试")]),e._v(" "),a("li",[a("code",[e._v("vue")]),e._v(" Vue 3 的主要入口，包括运行时和编译器，包括几个不同的入口（开发版本、runtime 版本、full 版本）")])]),e._v(" "),a("h3",{attrs:{id:"reactivity"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#reactivity"}},[e._v("#")]),e._v(" reactivity")]),e._v(" "),a("p",[e._v("整体流程")]),e._v(" "),a("p",[a("img",{attrs:{src:"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/87a4702e63fa4932929c86ec5e42ea1d~tplv-k3u1fbpfcp-watermark.image",alt:"1.png"}})]),e._v(" "),a("h4",{attrs:{id:"reactiveflags"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#reactiveflags"}},[e._v("#")]),e._v(" ReactiveFlags")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("export const enum ReactiveFlags {\n  skip = '__v_skip',\n  isReactive = '__v_isReactive',\n  isReadonly = '__v_isReadonly',\n  raw = '__v_raw',\n  reactive = '__v_reactive',\n  readonly = '__v_readonly'\n}\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br"),a("span",{staticClass:"line-number"},[e._v("8")]),a("br")])]),a("ul",[a("li",[e._v("代理对象会通过 "),a("code",[e._v("ReactiveFlags.raw")]),e._v(" 引用原始对象")]),e._v(" "),a("li",[e._v("原始对象会通过 "),a("code",[e._v("ReactiveFlags.reactive")]),e._v(" 或 "),a("code",[e._v("ReactiveFlags.readonly")]),e._v(" 引用代理对象")]),e._v(" "),a("li",[e._v("代理对象根据它是 "),a("code",[e._v("reactive")]),e._v(" 或 "),a("code",[e._v("readonly")]),e._v(" 的， 将 "),a("code",[e._v("ReactiveFlags.isReactive")]),e._v(" 或 "),a("code",[e._v("ReactiveFlags.isReadonly")]),e._v(" 属性值设置为 "),a("code",[e._v("true")])])]),e._v(" "),a("h4",{attrs:{id:"track与trigger"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#track与trigger"}},[e._v("#")]),e._v(" Track与Trigger")]),e._v(" "),a("p",[a("code",[e._v("track()")]),e._v(" 和 "),a("code",[e._v("trigger()")]),e._v(" 是依赖收集的核心，"),a("code",[e._v("track()")]),e._v(" 用来跟踪收集依赖(收集 "),a("code",[e._v("effect")]),e._v(")，"),a("code",[e._v("trigger()")]),e._v(" 用来触发响应(执行 "),a("code",[e._v("effect")]),e._v(")，它们需要配合 "),a("code",[e._v("effect()")]),e._v(" 函数使用")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("const obj = { foo: 1 }\neffect(() => {\n  console.log(obj.foo)\n  track(obj, TrackOpTypes.GET, 'foo')\n})\n\nobj.foo = 2\ntrigger(obj, TriggerOpTypes.SET, 'foo')\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br"),a("span",{staticClass:"line-number"},[e._v("8")]),a("br")])]),a("p",[e._v("track与trigger函数接受三个参数：")]),e._v(" "),a("ul",[a("li",[e._v("target：要跟踪的目标对象，这里就是 "),a("code",[e._v("obj")])]),e._v(" "),a("li",[e._v("跟踪操作的类型："),a("code",[e._v("obj.foo")]),e._v(" 是读取对象的值，因此是 "),a("code",[e._v("'get'")])]),e._v(" "),a("li",[e._v("key：要跟踪目标对象的 "),a("code",[e._v("key")]),e._v("，我们读取的是 "),a("code",[e._v("foo")]),e._v("，因此 "),a("code",[e._v("key")]),e._v(" 是 "),a("code",[e._v("foo")])])]),e._v(" "),a("p",[e._v("本质上建立一种数据结构：")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// 伪代码\nmap : {\n    [target]: {\n        [key]: [effect1, effect2....]\n    }\n}\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br")])]),a("p",[e._v("简单的理解，"),a("code",[e._v("effect")]),e._v(" 与对象和具体操作的 "),a("code",[e._v("key")]),e._v("，是以这种映射关系建立关联的：")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("[target]`----\x3e`key1`----\x3e`[effect1, effect2...]\n[target]`----\x3e`key2`----\x3e`[effect1, effect3...]\n[target2]`----\x3e`key1`----\x3e`[effect5, effect6...]\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br")])]),a("p",[e._v("既然 "),a("code",[e._v("effect")]),e._v(" 与目标对象 "),a("code",[e._v("target")]),e._v(" 已经建立了联系，那么当然就可以想办法通过 "),a("code",[e._v("target")]),e._v(" ----\x3e "),a("code",[e._v("key")]),e._v(" 进而取到 "),a("code",[e._v("effect")]),e._v(" ，然后执行它们，而这就是 "),a("code",[e._v("trigger()")]),e._v(" 函数做的事情，所以在调用 "),a("code",[e._v("trigger")]),e._v(" 函数时我们要指定目标对象和相应的"),a("code",[e._v("key")]),e._v("值。")]),e._v(" "),a("h4",{attrs:{id:"toref"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#toref"}},[e._v("#")]),e._v(" toRef")]),e._v(" "),a("p",[e._v("使用reactive 声明响应式对象有时出现对象的二次引用，造成响应丢失（对象解构返回渲染环境也会丢失响应）。")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("const obj = reactive({ foo: 1 }) // obj 是响应式数据\nconst obj2 = { foo: obj.foo }\n\neffect(() => {\n  console.log(obj2.foo) // 这里读取 obj2.foo\n})\n\nobj.foo = 2  // 设置 obj.foo 显然无效\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br"),a("span",{staticClass:"line-number"},[e._v("8")]),a("br")])]),a("p",[e._v("解决问题可以使用"),a("code",[e._v("toRef()")]),e._v(" 函数把响应式对象的某个Key值转换成ref。它的实现就直接set、get返回，因为target本身就是响应式的，所以无需track和trigger。")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("function toRef(target, key) {\n    return {\n        isRef: true,\n        get value() {\n            return target[key]\n        },\n        set value(newVal){\n            target[key] = newVal\n        }\n    }\n}\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br"),a("span",{staticClass:"line-number"},[e._v("8")]),a("br"),a("span",{staticClass:"line-number"},[e._v("9")]),a("br"),a("span",{staticClass:"line-number"},[e._v("10")]),a("br"),a("span",{staticClass:"line-number"},[e._v("11")]),a("br")])]),a("p",[e._v("但是ref的值需要.value访问值才行。如果不想要.value来取值，我们可以直接再包一层reactive。")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("const obj = reactive({ foo: 1 })\n// const obj2 = { foo: toRef(obj, 'foo') }\nconst obj2 = reactive({ ...toRefs(obj) })  // 让 obj2 也是 reactive\n\neffect(() => {\n  console.log(obj2.foo)  // 即使 obj2.foo 是 ref，我们也不需要 .value 来取值\n})\n\nobj.foo = 2 // 有效\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br"),a("span",{staticClass:"line-number"},[e._v("8")]),a("br"),a("span",{staticClass:"line-number"},[e._v("9")]),a("br")])]),a("p",[e._v("它的实现，发现值如果是ref，则返回.value。但这对于ref组成的数组，仍然需要.value来访问。")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("if (isRef(res)) {\n      // ref unwrapping - does not apply for Array + integer key.\n      const shouldUnwrap = !targetIsArray || !isIntegerKey(key)\n      return shouldUnwrap ? res.value : res\n    }\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br")])]),a("p",[e._v("通常使用ref()函数时，我们是为了引用原始数据类型，但引用非基本类型也是可以，比如：")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("const refObj=ref({foo:1})\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("refObj.value是一个对象，这对象是响应式的，修改refObj.value.foo会触发响应。而shallowRef是浅代理，只代理ref对象本身，也就是.value是被代理的，而.value所引用的对象并没有被代理，修改refObj.value.foo不会触发响应。那如果也要触发响应呢？Vue3提供triggerRef函数，可以让我们强制触发响应。")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("triggerRef(refObj) \n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("h3",{attrs:{id:"vue3-diff"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue3-diff"}},[e._v("#")]),e._v(" Vue3 Diff")]),e._v(" "),a("img",{staticStyle:{zoom:"200%"},attrs:{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c162ab65538f4e9592e78a3bcaa7cbd4~tplv-k3u1fbpfcp-zoom-1.image",alt:"image-20210618092346176"}}),e._v(" "),a("p",[a("strong",[e._v("大体流程：")])]),e._v(" "),a("ol",[a("li",[a("p",[e._v("从头对比找到有相同的节点 patch ，发现不同，立即跳出。")])]),e._v(" "),a("li",[a("p",[e._v("如果第一步没有patch完，立即，从后往前开始patch ,如果发现不同立即跳出循环。")])]),e._v(" "),a("li",[a("p",[e._v("如果新的节点大于老的节点数 ，对于剩下的节点全部以新的vnode处理（ 这种情况说明已经patch完相同的vnode ）。")])]),e._v(" "),a("li",[a("p",[e._v("对于老的节点大于新的节点的情况 ， 对于超出的节点全部卸载 （ 这种情况说明已经patch完相同的vnode ）。")])]),e._v(" "),a("li",[a("p",[e._v("不确定的元素（ 这种情况说明没有patch完相同的vnode ） 与 3 ，4对立关系。如下情况：")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("     // [i ... e1 + 1]: a b [c d e] f g\n\n     // [i ... e2 + 1]: a b [e d c h] f g\n\n     // i = 2, e1 = 4, e2 = 5\n\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br")])])])]),e._v(" "),a("ul",[a("li",[a("p",[e._v("把没有比较过的新的vnode节点,通过map保存，记录已经patch的新节点的数量 patched，没有经过 path 新的节点的数量 toBePatched")])]),e._v(" "),a("li",[a("p",[e._v("建立一个数组newIndexToOldIndexMap，每个子元素都是[ 0, 0, 0, 0, 0, 0, ] 里面的数字记录老节点的索引 ，数组索引就是新节点的索引")])]),e._v(" "),a("li",[a("p",[e._v("遍历老节点：")]),e._v(" "),a("ul",[a("li",[e._v("如果 toBePatched新的节点数量为0 ，那么统一卸载老的节点")]),e._v(" "),a("li",[e._v("如果,老节点的key存在 ，通过key找到对应的index")]),e._v(" "),a("li",[e._v("如果,老节点的key不存在：遍历剩下的所有新节点，如果找到与当前老节点对应的新节点那么 ，将新节点的索引，赋值给newIndex")]),e._v(" "),a("li",[e._v("没有找到与老节点对应的新节点，卸载当前老节点")]),e._v(" "),a("li",[e._v("如果找到与老节点对应的新节点，把老节点的索引，记录在存放新节点的数组中")])])]),e._v(" "),a("li",[a("p",[e._v("如果发生移动：")])])]),e._v(" "),a("ol",[a("li",[e._v("根据 newIndexToOldIndexMap 新老节点索引列表找到最长稳定序列")]),e._v(" "),a("li",[e._v("对于 newIndexToOldIndexMap[i] =0 证明不存在老节点 ，从新形成新的vnode")]),e._v(" "),a("li",[e._v("对移动的节点进行移动处理。")])]),e._v(" "),a("h4",{attrs:{id:"diff算法对比"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#diff算法对比"}},[e._v("#")]),e._v(" Diff算法对比：")]),e._v(" "),a("ul",[a("li",[e._v("React：遍历新节点序列在旧节点序列出现的位置，如果位置递增，则新节点不需要移动，否则节点后移。")]),e._v(" "),a("li",[e._v("Vue 2：双端比较。分别用新、旧节点序列的start跟end相互比较，查找复用，直到指针重合，退出循环。若四次对比都没找到复用节点，只能拿新序列的节点去旧序列依次对比。")]),e._v(" "),a("li",[e._v("Vue 3："),a("strong",[e._v("最长递增子序列")]),e._v("。生成List代表新节点序列不需要移动的index数组，从后向前遍历，若List[j]==index 说明节点不需要移动，否则节点插入队尾。")])])])}),[],!1,null,null,null);s.default=n.exports}}]);