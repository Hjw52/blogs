(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{565:function(s,n,a){"use strict";a.r(n);var t=a(13),e=Object(t.a)({},(function(){var s=this,n=s.$createElement,a=s._self._c||n;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("h3",{attrs:{id:"引言"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#引言"}},[s._v("#")]),s._v(" 引言")]),s._v(" "),a("p",[s._v("this 关键字是 JavaScript 中最复杂的机制之一。它是一个很特别的关键字，被自动定义在所有函数的作用域中。我们很难说清它到底执行什么。相对于词法作用域在声明的时候在其代码所在的位置确定的那种“"),a("strong",[s._v("静态")]),s._v("作用域”，this的指向就是“"),a("strong",[s._v("动态")]),s._v("”。this 是在运行时进行绑定的，并不是在编写时绑定，它的上下文取决于函数调 用时的各种条件。this 的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式。我们只有找到函数的调用位置，才能判断出它绑定的this。")]),s._v(" "),a("h3",{attrs:{id:"为什么用this"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为什么用this"}},[s._v("#")]),s._v(" 为什么用this")]),s._v(" "),a("p",[s._v("我们可以看下面这段代码：")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v('function identify() {\n\treturn this.name.toUpperCase();\n}\nfunction speak() {\n\tvar greeting = "Hello, I\'m " + identify.call( this );\n\tconsole.log( greeting );\n}\nvar me = {\n\tname: "Kyle"\n};\nvar you = {\n\tname: "Reader"\n};\nidentify.call( me ); // KYLE\nidentify.call( you ); // READER\nspeak.call( me ); // Hello, 我是 KYLE\nspeak.call( you ); // Hello, 我是 READER\n')])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br"),a("span",{staticClass:"line-number"},[s._v("15")]),a("br"),a("span",{staticClass:"line-number"},[s._v("16")]),a("br"),a("span",{staticClass:"line-number"},[s._v("17")]),a("br")])]),a("p",[s._v("这段代码函数针对不同的对象调用，显示出不同的结果，这也是this的用法之一，为函数指向调用它的上下文对象，隐式传递一个对象引用；如果不用this，则需要为函数定义形参，传入相应对象，如下：")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v('function identify(context) {\n\treturn context.name.toUpperCase();\n}\nfunction speak(context) {\n\tvar greeting = "Hello, I\'m " + identify( context );\n\tconsole.log( greeting );\n}\nidentify( you ); // READER\nspeak( me ); //hello, 我是 KYLE\n\n')])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br")])]),a("h3",{attrs:{id:"关于this"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#关于this"}},[s._v("#")]),s._v(" 关于this")]),s._v(" "),a("p",[s._v("也许很多人认为this指向函数自身，但在JavaScript，this的指向却是灵活多变的。我们看下思考代码：")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v('function foo(num) {\n\tconsole.log( "foo: " + num );\n\t// 记录 foo 被调用的次数\n\tthis.count++; //如果foo.count++;呢？\n}\nfoo.count = 0;\nvar i;\nfor (i=0; i<10; i++) {\n\tif (i > 5) {\n\tfoo( i );\n\t}\n}\n// foo: 6\n// foo: 7\n// foo: 8\n// foo: 9\n// foo 被调用了多少次？\nconsole.log( foo.count ); // 0 --疑惑？\n')])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br"),a("span",{staticClass:"line-number"},[s._v("15")]),a("br"),a("span",{staticClass:"line-number"},[s._v("16")]),a("br"),a("span",{staticClass:"line-number"},[s._v("17")]),a("br"),a("span",{staticClass:"line-number"},[s._v("18")]),a("br")])]),a("p",[s._v("console.log 语句产生了 4 条输出，证明 foo(..) 确实被调用了 4 次，但是 foo.count 仍然 是 0。为什么呢？其实这边this并不是指向foo函数，所以foo.count自然不会增加。（"),a("strong",[s._v("这边的this真正指向是window！具体的下面会讲")]),s._v("）")]),s._v(" "),a("p",[s._v("我们再看一个例子：")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("function foo() {\n\tvar a = 2;\n\tthis.bar();\n}\nfunction bar() {\n\tconsole.log( this.a );\n}\nfoo(); // ReferenceError: a is not defined\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br")])]),a("p",[s._v("这段代码按道理来说，随着作用域向上查找，应该可以输出a的值，然而这边却是"),a("strong",[s._v("引用错误，无法找到a变量")]),s._v("。为什么呢？首先，这段代码试图通过 this.bar() 来引用 bar() 函数。这是绝对不可能成功的，必须省略前面的this。其次，让 bar() 可以访问 foo() 作用域里的变量 a。这是不可能实现的，（这不像闭包）你不能使用 this 来引用一 个词法作用域内部的东西。")]),s._v(" "),a("p",[s._v("看了上面也许你有很多疑惑，其实这也是this最容易被误解的两点：")]),s._v(" "),a("ol",[a("li",[a("strong",[s._v("this指向函数自身")])]),s._v(" "),a("li",[a("strong",[s._v("this指向函数的作用域")]),s._v("（this 在任何情况下都不指向函数的词法作用域。在 JavaScript 内部，作用 域确实和对象类似，可见的标识符都是它的属性。但是作用域“对象”无法通过 JavaScript 代码访问，它存在于 JavaScript 引擎内部。）")])]),s._v(" "),a("p",[s._v("下面我们将从这两点出发，探索this的真正奥秘。")]),s._v(" "),a("h3",{attrs:{id:"this绑定"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#this绑定"}},[s._v("#")]),s._v(" this绑定")]),s._v(" "),a("p",[s._v("函数在执行过程中的调用位置决定了this的绑定对象，如何绑定通常有以下四条绑定规则。")]),s._v(" "),a("ol",[a("li",[a("strong",[s._v("默认绑定——无人调用指向全局")])])]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("function foo() {\n\tconsole.log( this.a );\n}\nvar a = 2;\nfoo(); // 2\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br")])]),a("p",[s._v("这边函数应用了默认绑定，因为在代码中，foo（）直接使用，不带任何修饰调用，无法应用其他规则。this指向全局对象。所以调用foo（）时，this.a被解析成全局变量，输出2。但要注意：在严格模式下，全局对象无法使用")]),s._v(" "),a("p",[s._v("默认绑定，this指向undefined,这也算是JavaScript的一种保护机制。")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v('function foo() {\n\t"use strict";\n\tconsole.log( this.a );//this在严格模式下\n}\nvar a = 2;\nfoo(); // TypeError: this is undefined\n\n//但下面的情况又是可以\nfunction foo() {\n\tconsole.log( this.a );//this不在严格模式下\n}\nvar a = 2;\n(function(){\n\t"use strict";\n\tfoo(); // 2\n})();\n')])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br"),a("span",{staticClass:"line-number"},[s._v("15")]),a("br"),a("span",{staticClass:"line-number"},[s._v("16")]),a("br")])]),a("p",[s._v("​\t2 ."),a("strong",[s._v("隐式绑定——谁调用指向谁")])]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("function foo() {\n\tconsole.log( this.a );\n}\nvar obj = {\n\ta: 2,\n\tfoo: foo\n};\nobj.foo(); // 2\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br")])]),a("p",[s._v("这段代码当 foo() 被调用时，它的落脚点确实指向 obj 对象。"),a("strong",[s._v("当函数引用有上下文对象时，隐式绑定规则会把函数调用中的 this 绑定到这个上下文对象")]),s._v("。因为调 用 foo() 时 this 被绑定到 obj，因此 this.a 和 obj.a 是一样的。但隐式绑定通常会存在绑定丢失的问题，从而把 this 绑定到全局对象或者 undefined 上。")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v('function foo() {\nconsole.log( this.a );\n}\nvar obj = {\n\ta: 2,\n\tfoo: foo\n};\nvar bar = obj.foo; // 函数别名！\nvar a = "oops, global"; // a 是全局对象的属性\nbar(); // "oops, global"\n')])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br")])]),a("p",[s._v("虽然 bar 是 obj.foo 的一个引用，但是实际上，它引用的是 foo 函数本身，因此此时的 bar() 其实是一个不带任何修饰的函数调用，因此应用了默认绑定。一种更常见的情况比如：")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v('function foo() {\n\tconsole.log( this.a );\n}\nfunction doFoo(fn) {\n\t// fn 其实引用的是 foo\n\tfn(); // <-- 调用位置！\n}\nvar obj = {\n\ta: 2,\n\tfoo: foo\n};\nvar a = "oops, global"; // a 是全局对象的属性\ndoFoo( obj.foo ); // "oops, global"\n')])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br")])]),a("p",[s._v("函数的传递容易造成绑定丢失的问题。")]),s._v(" "),a("ol",{attrs:{start:"3"}},[a("li",[a("strong",[s._v("显式绑定——固定绑定的对象")])])]),s._v(" "),a("p",[s._v("当我们想在某个对象上强制调用函数，这就需要使用显式绑定。可以使用函数的 call(..) 和 apply(..) 方法强制把this绑定到某个对象。它们接收的第一个参数是一个对象，它们会把这个对象绑定到 this，接着在调用函数时指定这个 this。")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("eg1:\n\nfunction foo() {\n\tconsole.log( this.a );\n}\nvar obj = {\n\ta:2\n};\nfoo.call( obj ); // 2\n\neg2:\n\nfunction foo() {\n\tconsole.log( this.a );\n}\nvar obj = {\n\ta:2\n};\nvar bar = function() {\n\tfoo.call( obj );\n};\nbar(); // 2\nsetTimeout( bar, 100 ); // 2\n// 硬绑定的 bar 不可能再修改它的 this\nbar.call( window ); // 2\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br"),a("span",{staticClass:"line-number"},[s._v("15")]),a("br"),a("span",{staticClass:"line-number"},[s._v("16")]),a("br"),a("span",{staticClass:"line-number"},[s._v("17")]),a("br"),a("span",{staticClass:"line-number"},[s._v("18")]),a("br"),a("span",{staticClass:"line-number"},[s._v("19")]),a("br"),a("span",{staticClass:"line-number"},[s._v("20")]),a("br"),a("span",{staticClass:"line-number"},[s._v("21")]),a("br"),a("span",{staticClass:"line-number"},[s._v("22")]),a("br"),a("span",{staticClass:"line-number"},[s._v("23")]),a("br"),a("span",{staticClass:"line-number"},[s._v("24")]),a("br"),a("span",{staticClass:"line-number"},[s._v("25")]),a("br")])]),a("p",[s._v("通过 foo.call()，我们可以在调用 foo 时强制把它的 this 绑定到 obj 上。这种绑定难以更改，我们称之为硬绑定。")]),s._v(" "),a("p",[s._v("​\t4. "),a("strong",[s._v("new绑定")])]),s._v(" "),a("p",[s._v("在这边需要明确知道："),a("strong",[s._v("JavaScript 中 new 的机制实 际上和面向类的语言完全不同")]),s._v("。在 JavaScript 中，构造函数只是一些 使用 new 操作符时被调用的函数。它们并不会属于某个类，也不会实例化一个类。")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("function foo(a) {\n\tthis.a = a;\n}\nvar bar = new foo(2);\nconsole.log( bar.a ); // 2\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br")])]),a("p",[s._v("当使用 new 来调用 foo(...) 时，我们会构造一个新对象并把它绑定到 foo(..) 调用中的 this 上。就像上面代码中的this指向了bar。")]),s._v(" "),a("h3",{attrs:{id:"绑定规则优先级"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#绑定规则优先级"}},[s._v("#")]),s._v(" 绑定规则优先级")]),s._v(" "),a("p",[s._v("我们已经了解了函数调用中 this 绑定的四条规则，你需要做的就是找到函数的调用位 置并判断应当应用哪条规则。但是，如果某个调用位置可以应用多条规则该怎么办？为了解决这个问题就必须给这些规则设定优先级。可以明确的是，默认绑定的优先级是四条规则中最低的。同时显式绑定比隐式绑定优先级高，那么显式绑定、隐式绑定。new绑定三者谁高谁低呢？")]),s._v(" "),a("p",[s._v("**new 绑定 **VS "),a("strong",[s._v("隐式绑定")])]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("function foo(something) {\n\tthis.a = something;\n}\nvar obj1 = {\n\tfoo: foo\n};\nvar obj2 = {};\nobj1.foo( 2 );\nconsole.log( obj1.a ); // 2\nobj1.foo.call( obj2, 3 );\nconsole.log( obj2.a ); // 3\nvar bar = new obj1.foo( 4 );\nconsole.log( obj1.a ); // 2\nconsole.log( bar.a ); // 4\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br")])]),a("p",[s._v("可以看出bar.a覆盖了obj1.a，所以new绑定的优先级比隐式绑定高。")]),s._v(" "),a("p",[s._v("**new 绑定 **VS "),a("strong",[s._v("显式绑定")])]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("function foo(something) {\n\tthis.a = something;\n}\nvar obj1 = {};\nvar bar = foo.bind( obj1 );\nbar( 2 );\nconsole.log( obj1.a ); // 2\nvar baz = new bar(3);\nconsole.log( obj1.a ); // 2\nconsole.log( baz.a ); // 3\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br")])]),a("p",[s._v("bar 被硬绑定到 obj1 上，但是 new bar(3) 并没有像我们预计的那样把 obj1.a 修改为 3。new 修改了硬绑定（到 obj1 的）调用 bar(..) 中的 this。因为使用了 new 绑定，我们得到了一个名字为 baz 的新对象，并且 baz.a 的值是 3。所以，优先级：new绑定大于显式绑定。")]),s._v(" "),a("h4",{attrs:{id:"综上"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#综上"}},[s._v("#")]),s._v(" 综上")]),s._v(" "),a("p",[s._v("优先级从高到低排列为：")]),s._v(" "),a("ol",[a("li",[a("strong",[s._v("new绑定")])]),s._v(" "),a("li",[a("strong",[s._v("显式绑定")])]),s._v(" "),a("li",[a("strong",[s._v("隐式绑定")])]),s._v(" "),a("li",[a("strong",[s._v("默认绑定")])])]),s._v(" "),a("h3",{attrs:{id:"箭头函数的this"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#箭头函数的this"}},[s._v("#")]),s._v(" 箭头函数的this")]),s._v(" "),a("p",[s._v("ES6 中加入了一种无法使用上面绑定规则的特殊函数类型：箭头函数。它的this是根据外层（函数或者全局）作用域来决 定 this。它继承外层函数调用的 this 绑定（无论 this 绑定到什么）。这 其实和 ES6 之前代码中的 self = this 机制一样。相比普通绑定规则的"),a("strong",[s._v("动态this")]),s._v("，箭头函数this显得有点**”静态“**。")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("function foo() {\n\t// 返回一个箭头函数\n\treturn (a) => {\n\t//this 继承自 foo()\n\tconsole.log( this.a );\n};\n}\nvar obj1 = {\na:2\n};\nvar obj2 = {\na:3\n};\nvar bar = foo.call( obj1 );\nbar.call( obj2 ); // 2, 不是 3 ！\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br"),a("span",{staticClass:"line-number"},[s._v("15")]),a("br")])]),a("p",[s._v("foo() 内部创建的箭头函数会捕获调用时 foo() 的 this。由于 foo() 的 this 绑定到 obj1， bar（引用箭头函数）的 this 也会绑定到 obj1，箭头函数的绑定无法被修改。（new 也无法修改）")])])}),[],!1,null,null,null);n.default=e.exports}}]);