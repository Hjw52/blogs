(window.webpackJsonp=window.webpackJsonp||[]).push([[26],{575:function(a,t,v){"use strict";v.r(t);var i=v(13),r=Object(i.a)({},(function(){var a=this,t=a.$createElement,v=a._self._c||t;return v("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[v("ul",[v("li",[v("h4",{attrs:{id:"解释性语言"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#解释性语言"}},[a._v("#")]),a._v(" 解释性语言")])])]),a._v(" "),v("p",[a._v("JavaScript属于解释性语言，它的语言特性让我们在编译时无法确定变量的类型（不能做偏移信息查找，偏移信息共享等编译优化），同时在运算时计算和决定类型会带来性能损失，这也是它比静态语言慢的原因。但现在JavaScript引擎做了很多优化，加入JIT等等，已经十分接近静态语言的性能了。")]),a._v(" "),v("p",[v("strong",[a._v("JavaScript与静态语言编译优化的区别：")])]),a._v(" "),v("ol",[v("li",[a._v("编译确定位置：静态语言在编译阶段就确定的对象的属性和偏移信息，而JavaScript没有类型，只有在对象创建时才有信息，也就是执行阶段才确定。")]),a._v(" "),v("li",[a._v("偏移信息共享：静态语言所有对象按类型确定，这些对象共享偏移信息，访问它们只需按照编译时确定的偏移量。而JavaScript每个对象都是自描述，属性和位置偏移都包含在自身的结构中。")]),a._v(" "),v("li",[a._v("偏移信息查找：静态语言对使用到的成员变量直接设置偏移量，而JavaScript使用到一个对象需要通过属性名匹配才能找到对应的值。")])]),a._v(" "),v("ul",[v("li",[v("h4",{attrs:{id:"jit-just-in-time"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#jit-just-in-time"}},[a._v("#")]),a._v(" JIT（just in time）")])])]),a._v(" "),v("p",[a._v("JavaScript为了提高运行速度加入了JIT技术，当解释器将源代码解释成内部表示时，JavaScript执行环境不仅解释这些内部表示而且将使用率较高的一些字节码转成本地代码（汇编）让CPU直接执行，而不是解释执行。这在Java虚拟机中也有应用。")]),a._v(" "),v("ul",[v("li",[v("h4",{attrs:{id:"javascript引擎"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#javascript引擎"}},[a._v("#")]),a._v(" JavaScript引擎")])])]),a._v(" "),v("p",[a._v("JavaScript引擎就是能够将JavaScript代码处理并执行的运行环境。")]),a._v(" "),v("p",[v("img",{attrs:{src:"https://github.com/Hjw52/Blog/blob/master/image/image-20201013091817685.png?raw=true",alt:"image-20201013091817685"}})]),a._v(" "),v("p",[a._v("js引擎先将源代码转为抽象语法树，抽象语法树再转为中间表示（字节码表示），然后JIT转成本地代码运行。当然V8引擎可以直接从抽象语法树到本地代码，不经过中间表示，更加提高效率。")]),a._v(" "),v("p",[a._v("一个JavaScript引擎通常包括：")]),a._v(" "),v("ol",[v("li",[a._v("编译器：将源代码编译成抽象语法树")]),a._v(" "),v("li",[a._v("解释器：解释执行字节码")]),a._v(" "),v("li",[a._v("JIT工具：将字节码或抽象语法树转换为本地代码")]),a._v(" "),v("li",[a._v("垃圾回收器：负责垃圾回收")])]),a._v(" "),v("ul",[v("li",[v("h4",{attrs:{id:"js引擎与渲染引擎"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#js引擎与渲染引擎"}},[a._v("#")]),a._v(" js引擎与渲染引擎")])])]),a._v(" "),v("p",[a._v("JavaScript引擎需要能够访问渲染引擎构建的DOM树，这往往通过桥接的接口。通过桥接接口这对性能来说是很大的损失，所以应避免JavaScript频繁地访问DOM。")]),a._v(" "),v("p",[v("img",{attrs:{src:"https://github.com/Hjw52/Blog/blob/master/image/image-20201013093217698.png?raw=true",alt:"image-20201013093217698"}})]),a._v(" "),v("ul",[v("li",[v("h4",{attrs:{id:"v8引擎"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#v8引擎"}},[a._v("#")]),a._v(" V8引擎")])])]),a._v(" "),v("p",[a._v("V8是谷歌的一个开源项目，是高性能JavaScript引擎的实现。它支持window,linux,mac等操作系统，也支持X64，arm，IA32等硬件架构。其中node就是基于V8的引擎。在v8中，数据表示分为数据实际内容和数据的句柄两部分，内容是变长的，类型也不一样，而句柄定长，包含指向数据的指针。")]),a._v(" "),v("p",[a._v("JavaScript对象在V8的内部表示有三个成员：")]),a._v(" "),v("p",[v("img",{attrs:{src:"https://github.com/Hjw52/Blog/blob/master/image/image-20201013094945684.png?raw=true",alt:"image-20201013094945684"}})]),a._v(" "),v("ol",[v("li",[a._v("隐藏类指针：v8为JavaScript对象创建的隐藏类（用于对相同属性名和属性值的对象构建类型信息，划分相同的组，组内共享信息）")]),a._v(" "),v("li",[a._v("属性表指针指向对象包含的属性值")]),a._v(" "),v("li",[a._v("元素表指针指向对象包含的元素")])]),a._v(" "),v("p",[v("strong",[a._v("隐藏类的例子：")])]),a._v(" "),v("p",[v("img",{attrs:{src:"https://github.com/Hjw52/Blog/blob/master/image/image-20201013100241250.png?raw=true",alt:"image-20201013100241250"}})]),a._v(" "),v("ul",[v("li",[v("h4",{attrs:{id:"内存管理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#内存管理"}},[a._v("#")]),a._v(" 内存管理")])])]),a._v(" "),v("p",[a._v("对于V8的内存划分，Zone类先申请一块内存，然后管理和分配一些小内存。小内存被分配后，不能被Zone回收，只能一次性回收分配的所有小内存。这有个缺陷，如果Zone分配了大量内存，但又不能够释放就会导致内存不足。")]),a._v(" "),v("p",[a._v("V8用堆来管理JavaScript数据，为了方便垃圾回收，v8堆主要分成三部分：")]),a._v(" "),v("p",[v("img",{attrs:{src:"https://github.com/Hjw52/Blog/blob/master/image/image-20201013103607822.png?raw=true",alt:"image-20201013103607822"}})]),a._v(" "),v("ul",[v("li",[a._v("年轻代：主要为新对象分配内存空间")]),a._v(" "),v("li",[a._v("年老代：较少地做垃圾回收")]),a._v(" "),v("li",[a._v("大对象：需要较多内存的大对象")])]),a._v(" "),v("p",[a._v("对于垃圾回收，主要采用标记清除法（标记清除也分多种，如下所示）。")]),a._v(" "),v("p",[v("img",{attrs:{src:"https://github.com/Hjw52/Node_learn/blob/master/image/image-20200928215651219.png?raw=true",alt:"image-20200928215651219"}})]),a._v(" "),v("p",[v("img",{attrs:{src:"https://github.com/Hjw52/Node_learn/blob/master/image/image-20200928215735206.png?raw=true",alt:"image-20200928215735206"}})]),a._v(" "),v("ul",[v("li",[v("h4",{attrs:{id:"v8为什么快"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#v8为什么快"}},[a._v("#")]),a._v(" V8为什么快？")])])]),a._v(" "),v("ol",[v("li",[v("p",[v("strong",[a._v("针对上下文的快照（Snapshot）技术")])]),a._v(" "),v("p",[a._v("快照技术即将内置对象和函数加载之后的内存保存并序列化，缩短启动时间。打开snapshot=on即可开启快照机制（但快照代码没法被优化编译器优化）。上下文（Contexts）则是JS应用程序的运行环境，避免应用程序的修改相互影响，例如一个页面js修改内置对象方法，不应该影响到另外页面。chrome浏览器每个process只有一个V8引擎实例，浏览器中的每个窗口、iframe都对应一个上下文。")])]),a._v(" "),v("li",[v("p",[v("strong",[a._v("Built-in代码")])]),a._v(" "),v("p",[a._v("利用JS自表达内置对象、方法。")])]),a._v(" "),v("li",[v("p",[v("strong",[a._v("AST的内存管理")])]),a._v(" "),v("p",[a._v("针对AST建立过程中多结点内存申请和一次性回收的特点，V8使用了内存段链表管理，并结合scopelock模式，实现少数申请（Segment，8KB~1MB）、多次分配AST结点、一次回收各个Segment的管理方式，既能避免内存碎片，又可以避免遍历AST结点逐个回收内存。")])]),a._v(" "),v("li",[v("p",[v("strong",[a._v("ComplieCache避免重复编译")])]),a._v(" "),v("p",[a._v("对于一段JS代码，在开始进行词法分析前，会从编译缓存区CompilationCache查找该段代码是否已经被编译过，如果是，则直接取出编译过的机器代码，并返回，这样降低CPU的使用率。")])]),a._v(" "),v("li",[v("p",[v("strong",[a._v("属性快速访问")])]),a._v(" "),v("p",[a._v("V8没有使用词典结构或红黑树实现的map来管理属性，而是在每个对象附加一个指针，指向隐藏类hidden class（如果第一次创建该类型对象，则新建hidden class）；当对象每添加一个属性时，将新建一个class（记录了每个属性的位移/位置），而原来的class指向新class，即建立起一个hidden class的转换链表。")])]),a._v(" "),v("li",[v("p",[v("strong",[a._v("一次性编译生成机器语言")])]),a._v(" "),v("p",[a._v("V8一次性把AST编译为机器语言，没有中间表示（通常先编译为字节码）。")])])])])}),[],!1,null,null,null);t.default=r.exports}}]);