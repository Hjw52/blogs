(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{568:function(n,s,t){"use strict";t.r(s);var a=t(13),e=Object(a.a)({},(function(){var n=this,s=n.$createElement,t=n._self._c||s;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("h3",{attrs:{id:"关于new的绑定"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#关于new的绑定"}},[n._v("#")]),n._v(" 关于new的绑定：")]),n._v(" "),t("ul",[t("li",[n._v("在JS中，构造函数只是使用new操作符时被调用的普通函数，他们不属于某个类，也不会实例化一个类。")]),n._v(" "),t("li",[n._v("包括内置对象函数（比如String(..)）在内的所有函数都可以用new来调用，这种函数调用被称为构造函数调用。")]),n._v(" "),t("li",[n._v("实际上并不存在所谓的“构造函数”，只有对于函数的“构造调用”。")])]),n._v(" "),t("h4",{attrs:{id:"使用new来调用函数-或者说发生构造函数调用时-会自动执行下面的操作"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#使用new来调用函数-或者说发生构造函数调用时-会自动执行下面的操作"}},[n._v("#")]),n._v(" "),t("strong",[n._v("使用new来调用函数，或者说发生构造函数调用时，会自动执行下面的操作：")])]),n._v(" "),t("p",[n._v("1、创建（或者说构造）一个新对象。")]),n._v(" "),t("p",[n._v("2、这个新对象会被执行[[Prototype]]连接。")]),n._v(" "),t("p",[n._v("3、这个新对象会绑定到函数调用的this。")]),n._v(" "),t("p",[n._v("4、如果函数没有返回其他对象，那么new表达式中的函数调用会自动返回这个新对象。")]),n._v(" "),t("p",[t("strong",[n._v("这也就是实现new的整个思路过程。")])]),n._v(" "),t("h5",{attrs:{id:"具体代码"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#具体代码"}},[n._v("#")]),n._v(" 具体代码：")]),n._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("function create() {\n\t// 创建一个空的对象\n    var obj = new Object(),\n\t// 获得构造函数，arguments中去除第一个参数\n    Con = [].shift.call(arguments);\n\t// 链接到原型，obj 可以访问到构造函数原型中的属性\n    obj.__proto__ = Con.prototype;\n\t// 绑定 this 实现继承，obj 可以访问到构造函数中的属性\n    var ret = Con.apply(obj, arguments);\n\t// 优先返回构造函数返回的对象\n\treturn ret instanceof Object ? ret : obj;\n};\n\n\n//使用create代替new\n\n\n\nfunction Person() {...}\n// 使用内置函数new\nvar person = new Person(...)\n                        \n// 使用手写的new，即create\nvar person = create(Person, ...)\n")])]),n._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[n._v("1")]),t("br"),t("span",{staticClass:"line-number"},[n._v("2")]),t("br"),t("span",{staticClass:"line-number"},[n._v("3")]),t("br"),t("span",{staticClass:"line-number"},[n._v("4")]),t("br"),t("span",{staticClass:"line-number"},[n._v("5")]),t("br"),t("span",{staticClass:"line-number"},[n._v("6")]),t("br"),t("span",{staticClass:"line-number"},[n._v("7")]),t("br"),t("span",{staticClass:"line-number"},[n._v("8")]),t("br"),t("span",{staticClass:"line-number"},[n._v("9")]),t("br"),t("span",{staticClass:"line-number"},[n._v("10")]),t("br"),t("span",{staticClass:"line-number"},[n._v("11")]),t("br"),t("span",{staticClass:"line-number"},[n._v("12")]),t("br"),t("span",{staticClass:"line-number"},[n._v("13")]),t("br"),t("span",{staticClass:"line-number"},[n._v("14")]),t("br"),t("span",{staticClass:"line-number"},[n._v("15")]),t("br"),t("span",{staticClass:"line-number"},[n._v("16")]),t("br"),t("span",{staticClass:"line-number"},[n._v("17")]),t("br"),t("span",{staticClass:"line-number"},[n._v("18")]),t("br"),t("span",{staticClass:"line-number"},[n._v("19")]),t("br"),t("span",{staticClass:"line-number"},[n._v("20")]),t("br"),t("span",{staticClass:"line-number"},[n._v("21")]),t("br"),t("span",{staticClass:"line-number"},[n._v("22")]),t("br"),t("span",{staticClass:"line-number"},[n._v("23")]),t("br"),t("span",{staticClass:"line-number"},[n._v("24")]),t("br")])]),t("h4",{attrs:{id:"原理解析"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#原理解析"}},[n._v("#")]),n._v(" 原理解析：")]),n._v(" "),t("ul",[t("li",[n._v("1、用new Object() 的方式新建了一个对象obj")]),n._v(" "),t("li",[n._v("2、取出第一个参数，就是我们要传入的构造函数。此外因为 shift 会修改原数组，所以 arguments 会被去除第一个参数")]),n._v(" "),t("li",[n._v("3、将 obj 的原型指向构造函数，这样obj就可以访问到构造函数原型中的属性")]),n._v(" "),t("li",[n._v("4、使用 apply，改变构造函数 this 的指向到新建的对象，这样 obj 就可以访问到构造函数中的属性")]),n._v(" "),t("li",[n._v("5、返回 obj")])]),n._v(" "),t("p",[t("strong",[n._v("概括来讲就是：新建一新对象，修改原型链指向构造函数和把构造函数this指向新对象并返回。")])])])}),[],!1,null,null,null);s.default=e.exports}}]);